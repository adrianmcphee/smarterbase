# SmarterBase - LLM Context File

## Project Overview

**SmarterBase** is a production-ready Go library that provides database-like functionality using Redis (for indexes) + S3/GCS (for storage) instead of traditional databases. It offers 85% cost savings compared to managed databases like RDS while maintaining high durability (S3's 11 9s) and availability.

**Key Value Proposition**: Turn existing infrastructure (Redis for caching, S3 for files) into a queryable, transactional document store with zero database operations overhead.

## Core Architecture

```
Application Layer
    ↓
IndexManager (coordinates all index updates)
    ↓
Store Layer (JSON marshaling, queries, transactions)
    ↓
Backend Layer (storage abstraction interface)
    ↓
Infrastructure (S3, GCS, Filesystem, MinIO)
```

### Key Components

1. **Backend Interface** (backend.go)
   - Abstraction for different storage systems
   - Implementations: S3, GCS, Filesystem, MinIO
   - Supports: Get/Put/Delete, streaming, append (JSONL), optimistic locking (ETags)

2. **Store** (store.go)
   - High-level operations on Backend
   - JSON marshaling/unmarshaling
   - Query builder with filtering/sorting
   - Batch operations
   - Observability (metrics, logging)

3. **Indexing System**
   - **File-based indexes** (indexer.go): 1:1 mappings (email → user)
   - **Redis indexes** (redis_indexer.go): 1:N mappings (user_id → [order1, order2])
   - **IndexManager** (index_manager.go): Coordinates updates across all index types

4. **Distributed Locking** (distributed_lock.go)
   - Redis-based locks prevent race conditions
   - Exponential backoff with retry
   - TTL protection prevents deadlocks
   - Lua scripts for atomic operations

5. **Reliability Features**
   - **Circuit Breaker** (circuit_breaker.go): Automatic failover when Redis unavailable
   - **Index Health Monitor** (index_health.go): Auto-detects and repairs drift
   - **Striped Locks** (striped_lock.go): 32x concurrency improvement for filesystem

6. **Transactions** (transaction.go)
   - Optimistic locking with ETag validation
   - Best-effort rollback (NOT ACID)
   - Use `WithAtomicUpdate()` + distributed locks for critical operations

7. **Encryption** (encryption.go)
   - AES-256-GCM encryption at rest
   - Random nonces per operation
   - Wraps any backend transparently

## Important Design Decisions & Limitations

### What SmarterBase IS:
- ✅ Document store with secondary indexes
- ✅ Queryable object storage
- ✅ Cost-effective database alternative for simple schemas
- ✅ Schema-less (JSON) with no migrations

### What SmarterBase is NOT:
- ❌ NOT a relational database (no JOINs)
- ❌ NOT ACID transactions (optimistic locking only)
- ❌ NOT for sub-millisecond latency (S3 = 50-100ms base latency)
- ❌ NOT for complex aggregations (use ClickHouse/BigQuery)

### Critical Gotchas

1. **S3 Race Conditions**: Always use `S3BackendWithRedisLock` for production (multi-writer)
2. **Transaction Isolation**: `WithTransaction()` is NOT isolated - use `WithAtomicUpdate()` + locks for critical operations
3. **Memory Usage**: `Query.All()` loads everything into memory - use `Each()` or pagination for large datasets
4. **Index Drift**: Enable `IndexHealthMonitor` to auto-detect and repair stale indexes

## Development Guidelines

### Code Style
- Follow standard Go conventions (gofmt, golint)
- Use interfaces for testability
- All operations accept `context.Context` as first parameter
- Comprehensive error handling with sentinel errors (errors.go)
- Add observability (metrics, logging) to all operations

### Testing Requirements
- Write tests for all new features
- Use table-driven tests for multiple scenarios
- Run with race detector: `go test -race`
- Separate fast unit tests from slow integration tests
- Integration tests use miniredis (in-memory) and testcontainers (MinIO)
- Maintain high coverage (current: 70%+)

### Commit Message Standards

**IMPORTANT**: All commit messages MUST follow this format:

```
<type>: <concise single sentence description>
```

**Allowed types** (semantic versioning):
- `feat:` - New feature
- `fix:` - Bug fix
- `docs:` - Documentation changes
- `refactor:` - Code refactoring (no functional changes)
- `test:` - Adding or updating tests
- `chore:` - Maintenance tasks (deps, build, release)
- `perf:` - Performance improvements
- `style:` - Code style changes (formatting, etc.)

**Examples**:
- ✅ `feat: add DynamoDB backend support`
- ✅ `fix: resolve race condition in concurrent index updates`
- ✅ `docs: update README with encryption examples`
- ✅ `refactor: simplify query builder interface`

**CRITICAL RULES**:
1. ❌ **Never mention AI/LLM assistance in commits**
2. ❌ Do NOT write multi-line commit messages unless absolutely necessary
3. ❌ Do NOT include Co-Authored-By unless user explicitly requests
4. ✅ Keep it simple, clear, and focused on WHAT changed
5. ✅ Use imperative mood ("add feature" not "added feature")

### Pre-commit Hooks
- Install hooks: `./scripts/install-hooks.sh`
- commit-msg hook validates conventional commit format
- pre-commit hook runs build and tests

### Godoc Documentation Standards

**CRITICAL**: SmarterBase's documentation is primarily accessed via `go doc`, not just README files.
This makes documentation **locally available** and **discoverable** for developers and AI assistants.

#### Documentation Files

1. **doc.go** (package-level documentation)
   - Comprehensive overview of the package
   - Quick start examples for common scenarios
   - Core concepts explanations
   - Links to README.md, DATASHEET.md, ADRs, examples, CHANGELOG.md
   - Critical gotchas and performance characteristics
   - When to use vs when NOT to use the package

2. **Inline godoc comments** (all exported types, functions, methods)
   - Every exported symbol MUST have a godoc comment
   - Comments should explain WHAT, WHY, and WHEN, not just HOW
   - Include examples for complex APIs
   - Link to relevant ADRs for architectural decisions

#### Godoc Comment Requirements

**For Functions and Methods:**
```go
// FunctionName does X and returns Y.
//
// Use this when you need to Z. Avoid using this for W because of limitation Q.
//
// Basic usage:
//
//	result, err := FunctionName(ctx, param)
//	if err != nil {
//	    // Handle error
//	}
//
// With advanced options:
//
//	result, err := FunctionName(ctx, param, WithOption(value))
//
// Performance: ~5ms typical latency. Scales to 10,000 ops/sec.
//
// See docs/adr/0001-feature-name.md for design rationale.
func FunctionName(ctx context.Context, param string) (Result, error) {
```

**For Types:**
```go
// TypeName represents X and is used for Y.
//
// Key fields:
//   - Field1: Description and constraints
//   - Field2: Description and default values
//
// Example:
//
//	obj := &TypeName{
//	    Field1: "value",
//	    Field2: 42,
//	}
type TypeName struct {
```

**For Constants:**
```go
// ConstName represents X and should be used when Y.
//
// Example:
//
//	config := Config{Mode: ConstName}
//
// See also: RelatedConst for Z scenarios.
const ConstName = "value"
```

#### When to Include Examples

**ALWAYS include examples for:**
- Public APIs that are commonly used (GetJSON, PutJSON, Migrate, etc.)
- Complex patterns (migrations, atomic updates, batch operations)
- APIs with non-obvious usage (ETag handling, migration policies)
- Helper functions (BatchGet, RedisOptions, etc.)

**Examples should show:**
- Basic usage (90% use case)
- Common variations (error handling, options)
- Edge cases or gotchas
- Before/after states where applicable

#### Linking to Documentation

**Reference documentation files explicitly:**
- ADRs: `See docs/adr/0001-schema-versioning-and-migrations.md for design rationale`
- README sections: `See README.md "Critical Gotchas" section`
- DATASHEET: `See DATASHEET.md for complete API reference`
- Examples: `See examples/schema-migrations/ for complete working example`

#### Testing Godoc Output

**Before committing documentation changes:**

```bash
# Test package-level docs
go doc github.com/adrianmcphee/smarterbase

# Test specific function
go doc github.com/adrianmcphee/smarterbase.Migrate

# Test type documentation
go doc github.com/adrianmcphee/smarterbase.Store

# Test method documentation
go doc github.com/adrianmcphee/smarterbase.Store.GetJSON

# Verify examples render correctly
go doc -all github.com/adrianmcphee/smarterbase | less
```

**Check that:**
- Examples use proper indentation (4 spaces or 1 tab after //)
- Code blocks are properly formatted
- Links to ADRs and docs are accurate
- Performance notes and gotchas are highlighted

#### Maintenance Checklist

**When adding a new public API:**
- [ ] Add comprehensive godoc comment with example
- [ ] Link to relevant ADR if it's a significant feature
- [ ] Include performance characteristics if relevant
- [ ] Add to doc.go if it's a core concept
- [ ] Test with `go doc` to verify rendering

**When modifying existing API:**
- [ ] Update godoc comment to reflect changes
- [ ] Update examples if behavior changed
- [ ] Update doc.go if it affects core concepts
- [ ] Note breaking changes in CHANGELOG.md
- [ ] Test with `go doc` to verify accuracy

**When creating a new feature:**
- [ ] Add section to doc.go if it's a core concept
- [ ] Document all exported APIs with examples
- [ ] Create ADR in docs/adr/ for architectural decisions
- [ ] Add working example to examples/ directory
- [ ] Update README.md with feature overview
- [ ] Test discoverability: `go doc | grep "feature-name"`

#### Common Patterns

**Migration documentation:**
```go
// Always include:
// - Before/after examples
// - Link to ADR-0001
// - Migration policy behavior
// - Performance impact
```

**Error handling documentation:**
```go
// Always include:
// - Which errors to check for (IsNotFound, IsConflict, etc.)
// - Retry strategies
// - Error context
```

**Performance documentation:**
```go
// Always include:
// - Typical latency
// - Scaling characteristics
// - Resource usage (memory, connections)
```

**Gotchas documentation:**
```go
// Always highlight:
// - Race conditions
// - Memory implications
// - Production considerations
```

#### Quality Standards

**Good godoc example:**
```go
// GetJSON fetches and unmarshals a JSON object from storage, applying migrations if needed.
//
// This is the primary method for reading data from smarterbase. It automatically handles
// schema migrations when the stored data version doesn't match the expected version.
//
// Basic usage:
//
//	var user User
//	err := store.GetJSON(ctx, "users/123.json", &user)
//	if smarterbase.IsNotFound(err) {
//	    // User doesn't exist
//	}
//
// Performance: ~50ns overhead when no migrations are registered. Migration adds 2-5ms per version step.
```

**Poor godoc example:**
```go
// GetJSON gets JSON
func (s *Store) GetJSON(ctx context.Context, key string, dest interface{}) error {
```

#### Documentation as Code

**Remember:**
- Godoc IS the primary API documentation
- README.md is for project overview and getting started
- DATASHEET.md is for technical specifications
- ADRs document architectural decisions
- Examples show complete working code
- Godoc ties everything together with links

**For AI assistants:**
When working with smarterbase code:
1. Start with `go doc github.com/adrianmcphee/smarterbase` for package overview
2. Use `go doc <symbol>` to look up specific APIs
3. Follow ADR links for design context
4. Check examples/ for complete patterns
5. All this is LOCAL in the Go module cache - no internet needed!

## Key Files to Understand

### Core Implementation
- `store.go` - Main Store API
- `backend.go` - Backend interface definition
- `s3_backend.go` - S3 implementation (190 lines)
- `s3_backend_with_lock.go` - S3 with Redis locking (63 lines)
- `redis_indexer.go` - Multi-value Redis indexes (424 lines)
- `distributed_lock.go` - Distributed locking (252 lines)
- `transaction.go` - Optimistic transactions (238 lines)
- `query.go` - Query builder (355 lines)

### Reliability
- `circuit_breaker.go` - Automatic failover
- `index_health.go` - Self-healing index monitoring (471 lines)
- `index_repair.go` - Index repair logic

### Observability
- `metrics.go` - Metrics interface
- `prometheus_metrics.go` - Prometheus implementation
- `logger.go` - Logging interface
- `zap_logger.go` - Zap structured logging

### Testing
- `*_test.go` - Unit tests
- `integration_test.go` - Integration tests (334 lines)
- `integration_advanced_test.go` - Advanced scenarios (374 lines)
- `*_comprehensive_test.go` - Comprehensive test suites
- `benchmark_test.go` - Performance benchmarks

## Common Patterns

### Creating a Production Store
```go
// S3 + Redis + Encryption + Observability
s3Client := s3.NewFromConfig(cfg)
redisClient := redis.NewClient(&redis.Options{Addr: "localhost:6379"})

backend := smarterbase.NewS3BackendWithRedisLock(s3Client, bucket, redisClient)
encKey := loadFromSecretsManager() // 32 bytes
encBackend, _ := smarterbase.NewEncryptionBackend(backend, encKey)

logger, _ := smarterbase.NewProductionZapLogger()
metrics := smarterbase.NewPrometheusMetrics(prometheus.DefaultRegisterer)
store := smarterbase.NewStoreWithObservability(encBackend, logger, metrics)
```

### Registering Indexes
```go
redisIndexer := smarterbase.NewRedisIndexer(redisClient)
redisIndexer.RegisterMultiIndex(&smarterbase.MultiIndexSpec{
    Name:       "users-by-email",
    EntityType: "users",
    ExtractFunc: smarterbase.ExtractJSONField("email"),
})

indexManager := smarterbase.NewIndexManager(store).
    WithRedisIndexer(redisIndexer)
```

### Atomic Updates (Critical Operations)
```go
lock := smarterbase.NewDistributedLock(redisClient, "smarterbase")
err := smarterbase.WithAtomicUpdate(ctx, store, lock, "accounts/123", 10*time.Second,
    func(ctx context.Context) error {
        var account Account
        store.GetJSON(ctx, "accounts/123", &account)
        account.Balance += 100
        store.PutJSON(ctx, "accounts/123", &account)
        return nil
    })
```

### Boilerplate Reduction Helpers (ADR-0006)

**NEW**: Three focused helpers that eliminate 85-90% of repetitive patterns:

#### 1. QueryWithFallback[T] - Redis → Scan Fallback Pattern
```go
// ✅ PREFERRED: One line replaces 50+ lines of manual fallback logic
users, err := smarterbase.QueryWithFallback[User](
    ctx, store, redisIndexer,
    "users", "role", "admin",              // Redis index lookup
    "users/",                               // Fallback scan prefix
    func(u *User) bool { return u.Role == "admin" },  // Fallback filter
)

// Automatically handles:
// - Try Redis index first (O(1))
// - Fall back to full scan if Redis unavailable (O(n))
// - Query profiling and complexity tracking
// - Index usage metrics
```

#### 2. UpdateWithIndexes - Coordinated Index Updates
```go
// ✅ PREFERRED: Prevents the common bug of forgetting to update indexes
err := smarterbase.UpdateWithIndexes(
    ctx, store, redisIndexer,
    "users/user-123.json", user,
    []smarterbase.IndexUpdate{
        {EntityType: "users", IndexField: "email", OldValue: oldEmail, NewValue: newEmail},
    },
)
```

#### 3. BatchGetWithFilter[T] - Filtered Batch Loading
```go
// ✅ PREFERRED: Load and filter in one call
activeUsers, err := smarterbase.BatchGetWithFilter[User](
    ctx, store, keys,
    func(u *User) bool { return u.Active },
)
```

**When to use these helpers:**
- Use QueryWithFallback for ALL Redis-indexed queries (production-patterns, user-management, ecommerce-orders examples)
- Use UpdateWithIndexes when updating indexed fields to prevent stale indexes
- Use BatchGetWithFilter when you need post-load filtering

**See:** [ADR-0006](docs/adr/0006-collection-api.md) for complete rationale and examples/production-patterns/ for reference implementation.

## Observability

### Metrics Tracked
- Backend operations: get/put/delete success/error counts
- Operation latency: histograms for all operations
- Query performance: duration and result counts
- Index health: drift percentage, repair success
- Circuit breaker: state transitions
- Lock contention: wait times, timeouts
- Transaction rollbacks: failure counts

### Logging
- Structured logging with Zap
- All operations logged with key, duration, error
- Index health checks and repairs logged
- Lock acquisition and contention logged

## CI/CD

### GitHub Actions
- **Test workflow** (.github/workflows/test.yml)
  - Matrix testing: Go 1.24 and 1.25
  - Unit tests with race detector
  - Integration tests with Redis and MinIO
  - Coverage reporting
- **Release workflow** (.github/workflows/release.yml)
  - Semantic versioning (semantic-release)
  - Automatic changelog generation
  - Git tag creation

### Running Tests Locally
```bash
# Quick tests (unit only)
go test -short -v

# All tests with race detection
go test -v -race

# Integration tests
go test -v -run Integration

# With coverage
go test -v -race -coverprofile=coverage.out
go tool cover -html=coverage.out
```

## Performance Characteristics

### Latency (Typical)
- Filesystem Get: 1-3ms
- S3 Get: 50-80ms
- Put with indexes: +5-10ms (Redis updates)
- Distributed lock: +2-5ms (no contention)

### Throughput
- Filesystem: 10,000+ ops/sec (with striped locks)
- S3: Up to 3,500 PUT/sec per prefix (AWS limit)

### Scalability
- Tested with millions of objects
- Redis can handle billions of index entries
- S3 scales infinitely

## Roadmap

### Completed ✅
- All storage backends (S3, GCS, Filesystem, MinIO)
- Distributed locking
- Multi-value Redis indexes
- Circuit breaker protection
- Self-healing index monitoring
- Encryption at rest
- Prometheus metrics
- Load testing framework
- Batch operations
- UUIDv7 IDs
- Schema versioning and migrations
- Comprehensive godoc documentation (doc.go, inline examples, ADR links)
- Local-first documentation accessible via `go doc`
- **ADR-0006: Boilerplate reduction helpers** (QueryWithFallback, UpdateWithIndexes, BatchGetWithFilter)

### Future ✨
- DynamoDB backend
- Full-text search (Elasticsearch integration)
- Index rebuild CLI tool
- Streaming query support
- Multi-backend replication
- Schema validation

## Contact & Resources

- **Repository**: https://github.com/adrianmcphee/smarterbase
- **License**: MIT
- **Documentation**: README.md, DATASHEET.md, CONTRIBUTING.md, SECURITY.md
- **Examples**: examples/ directory
- **Issues**: GitHub Issues for bugs and features
- **Security**: See SECURITY.md for reporting vulnerabilities

---

## Quick Reference for LLMs

**Before starting any work**:
⚠️ **ALWAYS run `git pull --rebase` first** to get latest changes from remote (CI may have pushed release commits)

**When making changes**:
1. Always run tests: `go test -v -race`
2. Check lint: `go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest && golangci-lint run`
3. Verify commit message format (semantic versioning)
4. Update tests for new features
5. **Update godoc comments** for any changed/added public APIs (see Godoc Documentation Standards above)
6. Test godoc rendering: `go doc <symbol>` to verify examples display correctly
7. Never reference AI assistance in commits
8. Before pushing: `git pull --rebase` again to catch any new CI commits

**Common tasks**:
- Adding backend: Implement `Backend` interface (backend.go) + godoc with examples
- Adding metrics: Update `metrics.go` and `prometheus_metrics.go` + godoc
- Adding index type: Extend `redis_indexer.go` or create new indexer + godoc with examples
- Performance improvement: Profile first, add benchmarks, then optimize + document in godoc
- Bug fix: Add failing test first, then fix, ensure test passes + update godoc if behavior changed
- New public API: Write godoc first (TDD for docs), then implement, then add examples
- Modifying API: Update godoc comments, test with `go doc`, ensure examples still work

**Architecture decisions to maintain**:
- Keep Backend interface simple and focused
- All operations use context.Context
- Observability is mandatory (metrics + logging)
- Security by default (encryption, locking available)
- Graceful degradation (circuit breakers, fallbacks)
- Clear error types with helpful context
- **Documentation-first**: Every public API has godoc with examples before merging
- **Local-first docs**: godoc is the source of truth, accessible via `go doc`
